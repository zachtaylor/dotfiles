# ~/.config/zsh/prompt

autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' unstagedstr '%F{yellow}!%f'
zstyle ':vcs_info:*' stagedstr '%F{green}+%f'
zstyle ':vcs_info:git*+set-message:*' hooks untracked-git

zstyle ':vcs_info:git*' formats "%F{cyan}%r [%b%f%m%u%c%F{cyan}]%f%F{blue}/%S%f"
zstyle ':vcs_info:git*' actionformats "%F{cyan}%r/%f%F{blue}%S%f [%F{cyan}%b%f (%a) %m%u%c]"

setopt prompt_subst no_prompt_{bang,subst} prompt_{cr,percent,sp}

function set_prompt {
    ## Set the values of PROMPT and RPROMPT here
    # Sample values given below
    # PROMPT='%~'$'\n''%# '
    # RPROMPT='%(?..%B%F{1}%?%f%b)'
	# set-prompt-1
		set-prompt-2
}

+vi-untracked-git() {
	if [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
			hook_com[misc]='%F{magenta}?%f'
	else
			hook_com[misc]=''
	fi
}

function preexec() {
	CMD_START_TIME=$(date +%s%3N)
}
function precmd() {
	vcs_info
	local dir
	set-dir-vcs
	TRANSIENT_PROMPT="$dir $ "

	if [ $CMD_START_TIME ]; then
		local now=$(date +%s%3N)

		local d_ms=$(($now - $CMD_START_TIME))
		local d_s=$((d_ms / 1000))
		local ms=$((d_ms % 1000))
		local s=$((d_s % 60))
		local m=$(((d_s / 60) % 60))
		local h=$((d_s / 3600))
		if ((h > 0)); then export CMD_DURATION_STR=${h}h${m}m
		elif ((m > 0)); then export CMD_DURATION_STR=${m}m${s}s
		elif ((s >= 10)); then export CMD_DURATION_STR=${s}.$((ms / 100))s
		elif ((s > 0)); then export CMD_DURATION_STR=${s}.$((ms / 10))s
		else export CMD_DURATION_STR=${ms}ms
		fi

		unset CMD_START_TIME
	fi
}

function prompt-length() {
	emulate -L zsh
	local -i COLUMNS=${2:-COLUMNS}
	local -i x y=${#1} m
	if (( y )); then
		while (( ${${(%):-$1%$y(l.1.0)}[-1]} )); do
			x=y
			(( y *= 2 ))
		done
		while (( y > x + 1 )); do
			(( m = x + (y - x) / 2 ))
			(( ${${(%):-$1%$m(l.x.y)}[-1]} = m ))
		done
	fi
	typeset -g REPLY=$x
}

function fill-line() {
	emulate -L zsh
	prompt-length $1
	local -i left_len=REPLY
	prompt-length $2 9999
	local -i right_len=REPLY # -1: don't count the newline char
	local -i pad_len=$((COLUMNS - left_len - right_len - ${ZLE_RPROMPT_INDENT:-1}))
	if (( pad_len < 2 )); then
		# Not enough space for the right part. Drop it.
		typeset -g REPLY=$1
	else
		local pad=${(pl.$pad_len.. .)}  # pad_len spaces
		typeset -g REPLY=${1}${pad}${2}
	fi
}

function set-dir-vcs() {
	[[ $SSH_CONNECTION ]] && local ssh_auth='%F{2}%n@%M%f '
	if [ $vcs_info_msg_0_ ]; then
		if [[ $(pwd) =~ "$HOME/*" ]]; then
			dir="${ssh_auth}%F{blue}~${${$(git rev-parse --show-toplevel)#${HOME}}%/*}/%f${vcs_info_msg_0_}"
		else
			dir="${ssh_auth}%F{blue}${$(pwd)%/*}/%f${vcs_info_msg_0_}"
		fi
	else
		dir="${ssh_auth}%F{blue}%~%f"
	fi
}

function set-prompt-2() {
	local dir
	set-dir-vcs
	local top_left="${dir}"
	local top_right="%F{yellow}${CMD_DURATION_STR}%f %*"
	local bottom_left='%B%F{%(?.white.red)}$%f%b '

	local REPLY
	fill-line "$top_left" "$top_right"
	PROMPT=$REPLY$'\n'$bottom_left
	unset RPROMPT
}

function set-prompt-1() {
	local dir
	set-dir-vcs
	PROMPT="${dir} %B%F{%(?.white.red)}$%f%b "
	RPROMPT="%F{yellow}${CMD_DURATION_STR}%f %*"
}

#### Transient prompt with transient newline before prompt

[[ -c /dev/null ]]  ||  return
zmodload zsh/system ||  return

## Set the transient prompt PROMPT here -
TRANSIENT_PROMPT='%# '   # Sample value

typeset -g _transient_prompt_newline=
function _transient_prompt_set_prompt {
    set_prompt
    PROMPT=$_transient_prompt_newline$PROMPT
}; _transient_prompt_set_prompt

zle -N clear-screen _transient_prompt_widget-clear-screen
function _transient_prompt_widget-clear-screen {
    _transient_prompt_newline=
    zle .clear-screen
}

zle -N send-break _transient_prompt_widget-send-break
function _transient_prompt_widget-send-break {
    _transient_prompt_widget-zle-line-finish
    zle .send-break
}

zle -N zle-line-finish _transient_prompt_widget-zle-line-finish
function _transient_prompt_widget-zle-line-finish {
    (( ! _transient_prompt_fd )) && {
        sysopen -r -o cloexec -u _transient_prompt_fd /dev/null
        zle -F $_transient_prompt_fd _transient_prompt_restore_prompt
    }
    zle && PROMPT=$TRANSIENT_PROMPT RPROMPT= zle reset-prompt && zle -R
}

function _transient_prompt_restore_prompt {
    exec {1}>&-
    (( ${+1} )) && zle -F $1
    _transient_prompt_fd=0
    _transient_prompt_set_prompt
    zle reset-prompt
    zle -R
}

(( ${+precmd_functions} )) || typeset -ga precmd_functions
(( ${#precmd_functions} )) || {
    do_nothing() {true}
    precmd_functions=(do_nothing)
}

precmd_functions+=_transient_prompt_precmd
function _transient_prompt_precmd {
    # We define _transient_prompt_precmd in this way because we don't want
    # _transient_prompt_newline to be defined on the very first precmd.
    TRAPINT() { zle && _transient_prompt_widget-zle-line-finish; return $(( 128 + $1 )) }
    function _transient_prompt_precmd {
        TRAPINT() {zle && _transient_prompt_widget-zle-line-finish; return $(( 128 + $1 ))}
        _transient_prompt_newline=$'\n'
    }
}

# vim: sw=0 ts=4 sts=4 et
